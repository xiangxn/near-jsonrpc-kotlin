/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.JsonRpcRequestForBlock
import org.openapitools.client.models.JsonRpcRequestForBlockEffects
import org.openapitools.client.models.JsonRpcRequestForBroadcastTxAsync
import org.openapitools.client.models.JsonRpcRequestForBroadcastTxCommit
import org.openapitools.client.models.JsonRpcRequestForChanges
import org.openapitools.client.models.JsonRpcRequestForChunk
import org.openapitools.client.models.JsonRpcRequestForClientConfig
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALChanges
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALChangesInBlock
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALCongestionLevel
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALGenesisConfig
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALLightClientBlockProof
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALLightClientProof
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALMaintenanceWindows
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALProtocolConfig
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALReceipt
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALSplitStorageInfo
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALTxStatus
import org.openapitools.client.models.JsonRpcRequestForEXPERIMENTALValidatorsOrdered
import org.openapitools.client.models.JsonRpcRequestForGasPrice
import org.openapitools.client.models.JsonRpcRequestForGenesisConfig
import org.openapitools.client.models.JsonRpcRequestForHealth
import org.openapitools.client.models.JsonRpcRequestForLightClientProof
import org.openapitools.client.models.JsonRpcRequestForMaintenanceWindows
import org.openapitools.client.models.JsonRpcRequestForNetworkInfo
import org.openapitools.client.models.JsonRpcRequestForNextLightClientBlock
import org.openapitools.client.models.JsonRpcRequestForQuery
import org.openapitools.client.models.JsonRpcRequestForSendTx
import org.openapitools.client.models.JsonRpcRequestForStatus
import org.openapitools.client.models.JsonRpcRequestForTx
import org.openapitools.client.models.JsonRpcRequestForValidators
import org.openapitools.client.models.JsonRpcResponseForArrayOfRangeOfUint64AndRpcError
import org.openapitools.client.models.JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError
import org.openapitools.client.models.JsonRpcResponseForCryptoHashAndRpcError
import org.openapitools.client.models.JsonRpcResponseForGenesisConfigAndRpcError
import org.openapitools.client.models.JsonRpcResponseForNullableRpcHealthResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcBlockResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcChunkResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcClientConfigResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcCongestionLevelResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcGasPriceResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcNetworkInfoResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcProtocolConfigResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcQueryResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcReceiptResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcStatusResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcTransactionResponseAndRpcError
import org.openapitools.client.models.JsonRpcResponseForRpcValidatorResponseAndRpcError

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /block
     * 
     * Returns block details for given height or hash
     * @param jsonRpcRequestForBlock 
     * @return JsonRpcResponseForRpcBlockResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun block(jsonRpcRequestForBlock: JsonRpcRequestForBlock) : JsonRpcResponseForRpcBlockResponseAndRpcError {
        val localVarResponse = blockWithHttpInfo(jsonRpcRequestForBlock = jsonRpcRequestForBlock)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcBlockResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /block
     * 
     * Returns block details for given height or hash
     * @param jsonRpcRequestForBlock 
     * @return ApiResponse<JsonRpcResponseForRpcBlockResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun blockWithHttpInfo(jsonRpcRequestForBlock: JsonRpcRequestForBlock) : ApiResponse<JsonRpcResponseForRpcBlockResponseAndRpcError?> {
        val localVariableConfig = blockRequestConfig(jsonRpcRequestForBlock = jsonRpcRequestForBlock)

        return request<JsonRpcRequestForBlock, JsonRpcResponseForRpcBlockResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation block
     *
     * @param jsonRpcRequestForBlock 
     * @return RequestConfig
     */
    fun blockRequestConfig(jsonRpcRequestForBlock: JsonRpcRequestForBlock) : RequestConfig<JsonRpcRequestForBlock> {
        val localVariableBody = jsonRpcRequestForBlock
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/block",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /block_effects
     * 
     * Returns changes in block for given block height or hash over all transactions for all the types. Includes changes like account_touched, access_key_touched, data_touched, contract_code_touched.
     * @param jsonRpcRequestForBlockEffects 
     * @return JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun blockEffects(jsonRpcRequestForBlockEffects: JsonRpcRequestForBlockEffects) : JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError {
        val localVarResponse = blockEffectsWithHttpInfo(jsonRpcRequestForBlockEffects = jsonRpcRequestForBlockEffects)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /block_effects
     * 
     * Returns changes in block for given block height or hash over all transactions for all the types. Includes changes like account_touched, access_key_touched, data_touched, contract_code_touched.
     * @param jsonRpcRequestForBlockEffects 
     * @return ApiResponse<JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun blockEffectsWithHttpInfo(jsonRpcRequestForBlockEffects: JsonRpcRequestForBlockEffects) : ApiResponse<JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError?> {
        val localVariableConfig = blockEffectsRequestConfig(jsonRpcRequestForBlockEffects = jsonRpcRequestForBlockEffects)

        return request<JsonRpcRequestForBlockEffects, JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation blockEffects
     *
     * @param jsonRpcRequestForBlockEffects 
     * @return RequestConfig
     */
    fun blockEffectsRequestConfig(jsonRpcRequestForBlockEffects: JsonRpcRequestForBlockEffects) : RequestConfig<JsonRpcRequestForBlockEffects> {
        val localVariableBody = jsonRpcRequestForBlockEffects
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/block_effects",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /broadcast_tx_async
     * 
     * [Deprecated] Sends a transaction and immediately returns transaction hash. Consider using send_tx instead.
     * @param jsonRpcRequestForBroadcastTxAsync 
     * @return JsonRpcResponseForCryptoHashAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun broadcastTxAsync(jsonRpcRequestForBroadcastTxAsync: JsonRpcRequestForBroadcastTxAsync) : JsonRpcResponseForCryptoHashAndRpcError {
        val localVarResponse = broadcastTxAsyncWithHttpInfo(jsonRpcRequestForBroadcastTxAsync = jsonRpcRequestForBroadcastTxAsync)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForCryptoHashAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /broadcast_tx_async
     * 
     * [Deprecated] Sends a transaction and immediately returns transaction hash. Consider using send_tx instead.
     * @param jsonRpcRequestForBroadcastTxAsync 
     * @return ApiResponse<JsonRpcResponseForCryptoHashAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun broadcastTxAsyncWithHttpInfo(jsonRpcRequestForBroadcastTxAsync: JsonRpcRequestForBroadcastTxAsync) : ApiResponse<JsonRpcResponseForCryptoHashAndRpcError?> {
        val localVariableConfig = broadcastTxAsyncRequestConfig(jsonRpcRequestForBroadcastTxAsync = jsonRpcRequestForBroadcastTxAsync)

        return request<JsonRpcRequestForBroadcastTxAsync, JsonRpcResponseForCryptoHashAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation broadcastTxAsync
     *
     * @param jsonRpcRequestForBroadcastTxAsync 
     * @return RequestConfig
     */
    fun broadcastTxAsyncRequestConfig(jsonRpcRequestForBroadcastTxAsync: JsonRpcRequestForBroadcastTxAsync) : RequestConfig<JsonRpcRequestForBroadcastTxAsync> {
        val localVariableBody = jsonRpcRequestForBroadcastTxAsync
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/broadcast_tx_async",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /broadcast_tx_commit
     * 
     * [Deprecated] Sends a transaction and waits until transaction is fully complete. (Has a 10 second timeout). Consider using send_tx instead.
     * @param jsonRpcRequestForBroadcastTxCommit 
     * @return JsonRpcResponseForRpcTransactionResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun broadcastTxCommit(jsonRpcRequestForBroadcastTxCommit: JsonRpcRequestForBroadcastTxCommit) : JsonRpcResponseForRpcTransactionResponseAndRpcError {
        val localVarResponse = broadcastTxCommitWithHttpInfo(jsonRpcRequestForBroadcastTxCommit = jsonRpcRequestForBroadcastTxCommit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcTransactionResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /broadcast_tx_commit
     * 
     * [Deprecated] Sends a transaction and waits until transaction is fully complete. (Has a 10 second timeout). Consider using send_tx instead.
     * @param jsonRpcRequestForBroadcastTxCommit 
     * @return ApiResponse<JsonRpcResponseForRpcTransactionResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun broadcastTxCommitWithHttpInfo(jsonRpcRequestForBroadcastTxCommit: JsonRpcRequestForBroadcastTxCommit) : ApiResponse<JsonRpcResponseForRpcTransactionResponseAndRpcError?> {
        val localVariableConfig = broadcastTxCommitRequestConfig(jsonRpcRequestForBroadcastTxCommit = jsonRpcRequestForBroadcastTxCommit)

        return request<JsonRpcRequestForBroadcastTxCommit, JsonRpcResponseForRpcTransactionResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation broadcastTxCommit
     *
     * @param jsonRpcRequestForBroadcastTxCommit 
     * @return RequestConfig
     */
    fun broadcastTxCommitRequestConfig(jsonRpcRequestForBroadcastTxCommit: JsonRpcRequestForBroadcastTxCommit) : RequestConfig<JsonRpcRequestForBroadcastTxCommit> {
        val localVariableBody = jsonRpcRequestForBroadcastTxCommit
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/broadcast_tx_commit",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /changes
     * 
     * Returns changes for a given account, contract or contract code for given block height or hash.
     * @param jsonRpcRequestForChanges 
     * @return JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun changes(jsonRpcRequestForChanges: JsonRpcRequestForChanges) : JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError {
        val localVarResponse = changesWithHttpInfo(jsonRpcRequestForChanges = jsonRpcRequestForChanges)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /changes
     * 
     * Returns changes for a given account, contract or contract code for given block height or hash.
     * @param jsonRpcRequestForChanges 
     * @return ApiResponse<JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun changesWithHttpInfo(jsonRpcRequestForChanges: JsonRpcRequestForChanges) : ApiResponse<JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError?> {
        val localVariableConfig = changesRequestConfig(jsonRpcRequestForChanges = jsonRpcRequestForChanges)

        return request<JsonRpcRequestForChanges, JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation changes
     *
     * @param jsonRpcRequestForChanges 
     * @return RequestConfig
     */
    fun changesRequestConfig(jsonRpcRequestForChanges: JsonRpcRequestForChanges) : RequestConfig<JsonRpcRequestForChanges> {
        val localVariableBody = jsonRpcRequestForChanges
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/changes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /chunk
     * 
     * Returns details of a specific chunk. You can run a block details query to get a valid chunk hash.
     * @param jsonRpcRequestForChunk 
     * @return JsonRpcResponseForRpcChunkResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chunk(jsonRpcRequestForChunk: JsonRpcRequestForChunk) : JsonRpcResponseForRpcChunkResponseAndRpcError {
        val localVarResponse = chunkWithHttpInfo(jsonRpcRequestForChunk = jsonRpcRequestForChunk)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcChunkResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /chunk
     * 
     * Returns details of a specific chunk. You can run a block details query to get a valid chunk hash.
     * @param jsonRpcRequestForChunk 
     * @return ApiResponse<JsonRpcResponseForRpcChunkResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chunkWithHttpInfo(jsonRpcRequestForChunk: JsonRpcRequestForChunk) : ApiResponse<JsonRpcResponseForRpcChunkResponseAndRpcError?> {
        val localVariableConfig = chunkRequestConfig(jsonRpcRequestForChunk = jsonRpcRequestForChunk)

        return request<JsonRpcRequestForChunk, JsonRpcResponseForRpcChunkResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chunk
     *
     * @param jsonRpcRequestForChunk 
     * @return RequestConfig
     */
    fun chunkRequestConfig(jsonRpcRequestForChunk: JsonRpcRequestForChunk) : RequestConfig<JsonRpcRequestForChunk> {
        val localVariableBody = jsonRpcRequestForChunk
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/chunk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /client_config
     * 
     * Queries client node configuration
     * @param jsonRpcRequestForClientConfig 
     * @return JsonRpcResponseForRpcClientConfigResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientConfig(jsonRpcRequestForClientConfig: JsonRpcRequestForClientConfig) : JsonRpcResponseForRpcClientConfigResponseAndRpcError {
        val localVarResponse = clientConfigWithHttpInfo(jsonRpcRequestForClientConfig = jsonRpcRequestForClientConfig)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcClientConfigResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /client_config
     * 
     * Queries client node configuration
     * @param jsonRpcRequestForClientConfig 
     * @return ApiResponse<JsonRpcResponseForRpcClientConfigResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun clientConfigWithHttpInfo(jsonRpcRequestForClientConfig: JsonRpcRequestForClientConfig) : ApiResponse<JsonRpcResponseForRpcClientConfigResponseAndRpcError?> {
        val localVariableConfig = clientConfigRequestConfig(jsonRpcRequestForClientConfig = jsonRpcRequestForClientConfig)

        return request<JsonRpcRequestForClientConfig, JsonRpcResponseForRpcClientConfigResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation clientConfig
     *
     * @param jsonRpcRequestForClientConfig 
     * @return RequestConfig
     */
    fun clientConfigRequestConfig(jsonRpcRequestForClientConfig: JsonRpcRequestForClientConfig) : RequestConfig<JsonRpcRequestForClientConfig> {
        val localVariableBody = jsonRpcRequestForClientConfig
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/client_config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_changes
     * 
     * [Deprecated] Returns changes for a given account, contract or contract code for given block height or hash. Consider using changes instead.
     * @param jsonRpcRequestForEXPERIMENTALChanges 
     * @return JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALChanges(jsonRpcRequestForEXPERIMENTALChanges: JsonRpcRequestForEXPERIMENTALChanges) : JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError {
        val localVarResponse = eXPERIMENTALChangesWithHttpInfo(jsonRpcRequestForEXPERIMENTALChanges = jsonRpcRequestForEXPERIMENTALChanges)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_changes
     * 
     * [Deprecated] Returns changes for a given account, contract or contract code for given block height or hash. Consider using changes instead.
     * @param jsonRpcRequestForEXPERIMENTALChanges 
     * @return ApiResponse<JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALChangesWithHttpInfo(jsonRpcRequestForEXPERIMENTALChanges: JsonRpcRequestForEXPERIMENTALChanges) : ApiResponse<JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALChangesRequestConfig(jsonRpcRequestForEXPERIMENTALChanges = jsonRpcRequestForEXPERIMENTALChanges)

        return request<JsonRpcRequestForEXPERIMENTALChanges, JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALChanges
     *
     * @param jsonRpcRequestForEXPERIMENTALChanges 
     * @return RequestConfig
     */
    fun eXPERIMENTALChangesRequestConfig(jsonRpcRequestForEXPERIMENTALChanges: JsonRpcRequestForEXPERIMENTALChanges) : RequestConfig<JsonRpcRequestForEXPERIMENTALChanges> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALChanges
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_changes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_changes_in_block
     * 
     * [Deprecated] Returns changes in block for given block height or hash over all transactions for all the types. Includes changes like account_touched, access_key_touched, data_touched, contract_code_touched. Consider using block_effects instead
     * @param jsonRpcRequestForEXPERIMENTALChangesInBlock 
     * @return JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALChangesInBlock(jsonRpcRequestForEXPERIMENTALChangesInBlock: JsonRpcRequestForEXPERIMENTALChangesInBlock) : JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError {
        val localVarResponse = eXPERIMENTALChangesInBlockWithHttpInfo(jsonRpcRequestForEXPERIMENTALChangesInBlock = jsonRpcRequestForEXPERIMENTALChangesInBlock)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_changes_in_block
     * 
     * [Deprecated] Returns changes in block for given block height or hash over all transactions for all the types. Includes changes like account_touched, access_key_touched, data_touched, contract_code_touched. Consider using block_effects instead
     * @param jsonRpcRequestForEXPERIMENTALChangesInBlock 
     * @return ApiResponse<JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALChangesInBlockWithHttpInfo(jsonRpcRequestForEXPERIMENTALChangesInBlock: JsonRpcRequestForEXPERIMENTALChangesInBlock) : ApiResponse<JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALChangesInBlockRequestConfig(jsonRpcRequestForEXPERIMENTALChangesInBlock = jsonRpcRequestForEXPERIMENTALChangesInBlock)

        return request<JsonRpcRequestForEXPERIMENTALChangesInBlock, JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALChangesInBlock
     *
     * @param jsonRpcRequestForEXPERIMENTALChangesInBlock 
     * @return RequestConfig
     */
    fun eXPERIMENTALChangesInBlockRequestConfig(jsonRpcRequestForEXPERIMENTALChangesInBlock: JsonRpcRequestForEXPERIMENTALChangesInBlock) : RequestConfig<JsonRpcRequestForEXPERIMENTALChangesInBlock> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALChangesInBlock
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_changes_in_block",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_congestion_level
     * 
     * Queries the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight&#x3D;congestion#receipt-congestion)
     * @param jsonRpcRequestForEXPERIMENTALCongestionLevel 
     * @return JsonRpcResponseForRpcCongestionLevelResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALCongestionLevel(jsonRpcRequestForEXPERIMENTALCongestionLevel: JsonRpcRequestForEXPERIMENTALCongestionLevel) : JsonRpcResponseForRpcCongestionLevelResponseAndRpcError {
        val localVarResponse = eXPERIMENTALCongestionLevelWithHttpInfo(jsonRpcRequestForEXPERIMENTALCongestionLevel = jsonRpcRequestForEXPERIMENTALCongestionLevel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcCongestionLevelResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_congestion_level
     * 
     * Queries the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight&#x3D;congestion#receipt-congestion)
     * @param jsonRpcRequestForEXPERIMENTALCongestionLevel 
     * @return ApiResponse<JsonRpcResponseForRpcCongestionLevelResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALCongestionLevelWithHttpInfo(jsonRpcRequestForEXPERIMENTALCongestionLevel: JsonRpcRequestForEXPERIMENTALCongestionLevel) : ApiResponse<JsonRpcResponseForRpcCongestionLevelResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALCongestionLevelRequestConfig(jsonRpcRequestForEXPERIMENTALCongestionLevel = jsonRpcRequestForEXPERIMENTALCongestionLevel)

        return request<JsonRpcRequestForEXPERIMENTALCongestionLevel, JsonRpcResponseForRpcCongestionLevelResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALCongestionLevel
     *
     * @param jsonRpcRequestForEXPERIMENTALCongestionLevel 
     * @return RequestConfig
     */
    fun eXPERIMENTALCongestionLevelRequestConfig(jsonRpcRequestForEXPERIMENTALCongestionLevel: JsonRpcRequestForEXPERIMENTALCongestionLevel) : RequestConfig<JsonRpcRequestForEXPERIMENTALCongestionLevel> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALCongestionLevel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_congestion_level",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_genesis_config
     * 
     * [Deprecated] Get initial state and parameters for the genesis block. Consider genesis_config instead.
     * @param jsonRpcRequestForEXPERIMENTALGenesisConfig 
     * @return JsonRpcResponseForGenesisConfigAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALGenesisConfig(jsonRpcRequestForEXPERIMENTALGenesisConfig: JsonRpcRequestForEXPERIMENTALGenesisConfig) : JsonRpcResponseForGenesisConfigAndRpcError {
        val localVarResponse = eXPERIMENTALGenesisConfigWithHttpInfo(jsonRpcRequestForEXPERIMENTALGenesisConfig = jsonRpcRequestForEXPERIMENTALGenesisConfig)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForGenesisConfigAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_genesis_config
     * 
     * [Deprecated] Get initial state and parameters for the genesis block. Consider genesis_config instead.
     * @param jsonRpcRequestForEXPERIMENTALGenesisConfig 
     * @return ApiResponse<JsonRpcResponseForGenesisConfigAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALGenesisConfigWithHttpInfo(jsonRpcRequestForEXPERIMENTALGenesisConfig: JsonRpcRequestForEXPERIMENTALGenesisConfig) : ApiResponse<JsonRpcResponseForGenesisConfigAndRpcError?> {
        val localVariableConfig = eXPERIMENTALGenesisConfigRequestConfig(jsonRpcRequestForEXPERIMENTALGenesisConfig = jsonRpcRequestForEXPERIMENTALGenesisConfig)

        return request<JsonRpcRequestForEXPERIMENTALGenesisConfig, JsonRpcResponseForGenesisConfigAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALGenesisConfig
     *
     * @param jsonRpcRequestForEXPERIMENTALGenesisConfig 
     * @return RequestConfig
     */
    fun eXPERIMENTALGenesisConfigRequestConfig(jsonRpcRequestForEXPERIMENTALGenesisConfig: JsonRpcRequestForEXPERIMENTALGenesisConfig) : RequestConfig<JsonRpcRequestForEXPERIMENTALGenesisConfig> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALGenesisConfig
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_genesis_config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_light_client_block_proof
     * 
     * Returns the proofs for a transaction execution.
     * @param jsonRpcRequestForEXPERIMENTALLightClientBlockProof 
     * @return JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALLightClientBlockProof(jsonRpcRequestForEXPERIMENTALLightClientBlockProof: JsonRpcRequestForEXPERIMENTALLightClientBlockProof) : JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError {
        val localVarResponse = eXPERIMENTALLightClientBlockProofWithHttpInfo(jsonRpcRequestForEXPERIMENTALLightClientBlockProof = jsonRpcRequestForEXPERIMENTALLightClientBlockProof)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_light_client_block_proof
     * 
     * Returns the proofs for a transaction execution.
     * @param jsonRpcRequestForEXPERIMENTALLightClientBlockProof 
     * @return ApiResponse<JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALLightClientBlockProofWithHttpInfo(jsonRpcRequestForEXPERIMENTALLightClientBlockProof: JsonRpcRequestForEXPERIMENTALLightClientBlockProof) : ApiResponse<JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALLightClientBlockProofRequestConfig(jsonRpcRequestForEXPERIMENTALLightClientBlockProof = jsonRpcRequestForEXPERIMENTALLightClientBlockProof)

        return request<JsonRpcRequestForEXPERIMENTALLightClientBlockProof, JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALLightClientBlockProof
     *
     * @param jsonRpcRequestForEXPERIMENTALLightClientBlockProof 
     * @return RequestConfig
     */
    fun eXPERIMENTALLightClientBlockProofRequestConfig(jsonRpcRequestForEXPERIMENTALLightClientBlockProof: JsonRpcRequestForEXPERIMENTALLightClientBlockProof) : RequestConfig<JsonRpcRequestForEXPERIMENTALLightClientBlockProof> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALLightClientBlockProof
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_light_client_block_proof",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_light_client_proof
     * 
     * Returns the proofs for a transaction execution.
     * @param jsonRpcRequestForEXPERIMENTALLightClientProof 
     * @return JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALLightClientProof(jsonRpcRequestForEXPERIMENTALLightClientProof: JsonRpcRequestForEXPERIMENTALLightClientProof) : JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError {
        val localVarResponse = eXPERIMENTALLightClientProofWithHttpInfo(jsonRpcRequestForEXPERIMENTALLightClientProof = jsonRpcRequestForEXPERIMENTALLightClientProof)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_light_client_proof
     * 
     * Returns the proofs for a transaction execution.
     * @param jsonRpcRequestForEXPERIMENTALLightClientProof 
     * @return ApiResponse<JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALLightClientProofWithHttpInfo(jsonRpcRequestForEXPERIMENTALLightClientProof: JsonRpcRequestForEXPERIMENTALLightClientProof) : ApiResponse<JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALLightClientProofRequestConfig(jsonRpcRequestForEXPERIMENTALLightClientProof = jsonRpcRequestForEXPERIMENTALLightClientProof)

        return request<JsonRpcRequestForEXPERIMENTALLightClientProof, JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALLightClientProof
     *
     * @param jsonRpcRequestForEXPERIMENTALLightClientProof 
     * @return RequestConfig
     */
    fun eXPERIMENTALLightClientProofRequestConfig(jsonRpcRequestForEXPERIMENTALLightClientProof: JsonRpcRequestForEXPERIMENTALLightClientProof) : RequestConfig<JsonRpcRequestForEXPERIMENTALLightClientProof> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALLightClientProof
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_light_client_proof",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_maintenance_windows
     * 
     * [Deprecated] Returns the future windows for maintenance in current epoch for the specified account. In the maintenance windows, the node will not be block producer or chunk producer. Consider using maintenance_windows instead.
     * @param jsonRpcRequestForEXPERIMENTALMaintenanceWindows 
     * @return JsonRpcResponseForArrayOfRangeOfUint64AndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALMaintenanceWindows(jsonRpcRequestForEXPERIMENTALMaintenanceWindows: JsonRpcRequestForEXPERIMENTALMaintenanceWindows) : JsonRpcResponseForArrayOfRangeOfUint64AndRpcError {
        val localVarResponse = eXPERIMENTALMaintenanceWindowsWithHttpInfo(jsonRpcRequestForEXPERIMENTALMaintenanceWindows = jsonRpcRequestForEXPERIMENTALMaintenanceWindows)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForArrayOfRangeOfUint64AndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_maintenance_windows
     * 
     * [Deprecated] Returns the future windows for maintenance in current epoch for the specified account. In the maintenance windows, the node will not be block producer or chunk producer. Consider using maintenance_windows instead.
     * @param jsonRpcRequestForEXPERIMENTALMaintenanceWindows 
     * @return ApiResponse<JsonRpcResponseForArrayOfRangeOfUint64AndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALMaintenanceWindowsWithHttpInfo(jsonRpcRequestForEXPERIMENTALMaintenanceWindows: JsonRpcRequestForEXPERIMENTALMaintenanceWindows) : ApiResponse<JsonRpcResponseForArrayOfRangeOfUint64AndRpcError?> {
        val localVariableConfig = eXPERIMENTALMaintenanceWindowsRequestConfig(jsonRpcRequestForEXPERIMENTALMaintenanceWindows = jsonRpcRequestForEXPERIMENTALMaintenanceWindows)

        return request<JsonRpcRequestForEXPERIMENTALMaintenanceWindows, JsonRpcResponseForArrayOfRangeOfUint64AndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALMaintenanceWindows
     *
     * @param jsonRpcRequestForEXPERIMENTALMaintenanceWindows 
     * @return RequestConfig
     */
    fun eXPERIMENTALMaintenanceWindowsRequestConfig(jsonRpcRequestForEXPERIMENTALMaintenanceWindows: JsonRpcRequestForEXPERIMENTALMaintenanceWindows) : RequestConfig<JsonRpcRequestForEXPERIMENTALMaintenanceWindows> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALMaintenanceWindows
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_maintenance_windows",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_protocol_config
     * 
     * A configuration that defines the protocol-level parameters such as gas/storage costs, limits, feature flags, other settings
     * @param jsonRpcRequestForEXPERIMENTALProtocolConfig 
     * @return JsonRpcResponseForRpcProtocolConfigResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALProtocolConfig(jsonRpcRequestForEXPERIMENTALProtocolConfig: JsonRpcRequestForEXPERIMENTALProtocolConfig) : JsonRpcResponseForRpcProtocolConfigResponseAndRpcError {
        val localVarResponse = eXPERIMENTALProtocolConfigWithHttpInfo(jsonRpcRequestForEXPERIMENTALProtocolConfig = jsonRpcRequestForEXPERIMENTALProtocolConfig)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcProtocolConfigResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_protocol_config
     * 
     * A configuration that defines the protocol-level parameters such as gas/storage costs, limits, feature flags, other settings
     * @param jsonRpcRequestForEXPERIMENTALProtocolConfig 
     * @return ApiResponse<JsonRpcResponseForRpcProtocolConfigResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALProtocolConfigWithHttpInfo(jsonRpcRequestForEXPERIMENTALProtocolConfig: JsonRpcRequestForEXPERIMENTALProtocolConfig) : ApiResponse<JsonRpcResponseForRpcProtocolConfigResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALProtocolConfigRequestConfig(jsonRpcRequestForEXPERIMENTALProtocolConfig = jsonRpcRequestForEXPERIMENTALProtocolConfig)

        return request<JsonRpcRequestForEXPERIMENTALProtocolConfig, JsonRpcResponseForRpcProtocolConfigResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALProtocolConfig
     *
     * @param jsonRpcRequestForEXPERIMENTALProtocolConfig 
     * @return RequestConfig
     */
    fun eXPERIMENTALProtocolConfigRequestConfig(jsonRpcRequestForEXPERIMENTALProtocolConfig: JsonRpcRequestForEXPERIMENTALProtocolConfig) : RequestConfig<JsonRpcRequestForEXPERIMENTALProtocolConfig> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALProtocolConfig
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_protocol_config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_receipt
     * 
     * Fetches a receipt by its ID (as is, without a status or execution outcome)
     * @param jsonRpcRequestForEXPERIMENTALReceipt 
     * @return JsonRpcResponseForRpcReceiptResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALReceipt(jsonRpcRequestForEXPERIMENTALReceipt: JsonRpcRequestForEXPERIMENTALReceipt) : JsonRpcResponseForRpcReceiptResponseAndRpcError {
        val localVarResponse = eXPERIMENTALReceiptWithHttpInfo(jsonRpcRequestForEXPERIMENTALReceipt = jsonRpcRequestForEXPERIMENTALReceipt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcReceiptResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_receipt
     * 
     * Fetches a receipt by its ID (as is, without a status or execution outcome)
     * @param jsonRpcRequestForEXPERIMENTALReceipt 
     * @return ApiResponse<JsonRpcResponseForRpcReceiptResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALReceiptWithHttpInfo(jsonRpcRequestForEXPERIMENTALReceipt: JsonRpcRequestForEXPERIMENTALReceipt) : ApiResponse<JsonRpcResponseForRpcReceiptResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALReceiptRequestConfig(jsonRpcRequestForEXPERIMENTALReceipt = jsonRpcRequestForEXPERIMENTALReceipt)

        return request<JsonRpcRequestForEXPERIMENTALReceipt, JsonRpcResponseForRpcReceiptResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALReceipt
     *
     * @param jsonRpcRequestForEXPERIMENTALReceipt 
     * @return RequestConfig
     */
    fun eXPERIMENTALReceiptRequestConfig(jsonRpcRequestForEXPERIMENTALReceipt: JsonRpcRequestForEXPERIMENTALReceipt) : RequestConfig<JsonRpcRequestForEXPERIMENTALReceipt> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALReceipt
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_receipt",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_split_storage_info
     * 
     * Contains the split storage information. More info on split storage [here](https://near-nodes.io/archival/split-storage-archival)
     * @param jsonRpcRequestForEXPERIMENTALSplitStorageInfo 
     * @return JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALSplitStorageInfo(jsonRpcRequestForEXPERIMENTALSplitStorageInfo: JsonRpcRequestForEXPERIMENTALSplitStorageInfo) : JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError {
        val localVarResponse = eXPERIMENTALSplitStorageInfoWithHttpInfo(jsonRpcRequestForEXPERIMENTALSplitStorageInfo = jsonRpcRequestForEXPERIMENTALSplitStorageInfo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_split_storage_info
     * 
     * Contains the split storage information. More info on split storage [here](https://near-nodes.io/archival/split-storage-archival)
     * @param jsonRpcRequestForEXPERIMENTALSplitStorageInfo 
     * @return ApiResponse<JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALSplitStorageInfoWithHttpInfo(jsonRpcRequestForEXPERIMENTALSplitStorageInfo: JsonRpcRequestForEXPERIMENTALSplitStorageInfo) : ApiResponse<JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALSplitStorageInfoRequestConfig(jsonRpcRequestForEXPERIMENTALSplitStorageInfo = jsonRpcRequestForEXPERIMENTALSplitStorageInfo)

        return request<JsonRpcRequestForEXPERIMENTALSplitStorageInfo, JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALSplitStorageInfo
     *
     * @param jsonRpcRequestForEXPERIMENTALSplitStorageInfo 
     * @return RequestConfig
     */
    fun eXPERIMENTALSplitStorageInfoRequestConfig(jsonRpcRequestForEXPERIMENTALSplitStorageInfo: JsonRpcRequestForEXPERIMENTALSplitStorageInfo) : RequestConfig<JsonRpcRequestForEXPERIMENTALSplitStorageInfo> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALSplitStorageInfo
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_split_storage_info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_tx_status
     * 
     * Queries status of a transaction by hash, returning the final transaction result and details of all receipts.
     * @param jsonRpcRequestForEXPERIMENTALTxStatus 
     * @return JsonRpcResponseForRpcTransactionResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALTxStatus(jsonRpcRequestForEXPERIMENTALTxStatus: JsonRpcRequestForEXPERIMENTALTxStatus) : JsonRpcResponseForRpcTransactionResponseAndRpcError {
        val localVarResponse = eXPERIMENTALTxStatusWithHttpInfo(jsonRpcRequestForEXPERIMENTALTxStatus = jsonRpcRequestForEXPERIMENTALTxStatus)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcTransactionResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_tx_status
     * 
     * Queries status of a transaction by hash, returning the final transaction result and details of all receipts.
     * @param jsonRpcRequestForEXPERIMENTALTxStatus 
     * @return ApiResponse<JsonRpcResponseForRpcTransactionResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALTxStatusWithHttpInfo(jsonRpcRequestForEXPERIMENTALTxStatus: JsonRpcRequestForEXPERIMENTALTxStatus) : ApiResponse<JsonRpcResponseForRpcTransactionResponseAndRpcError?> {
        val localVariableConfig = eXPERIMENTALTxStatusRequestConfig(jsonRpcRequestForEXPERIMENTALTxStatus = jsonRpcRequestForEXPERIMENTALTxStatus)

        return request<JsonRpcRequestForEXPERIMENTALTxStatus, JsonRpcResponseForRpcTransactionResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALTxStatus
     *
     * @param jsonRpcRequestForEXPERIMENTALTxStatus 
     * @return RequestConfig
     */
    fun eXPERIMENTALTxStatusRequestConfig(jsonRpcRequestForEXPERIMENTALTxStatus: JsonRpcRequestForEXPERIMENTALTxStatus) : RequestConfig<JsonRpcRequestForEXPERIMENTALTxStatus> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALTxStatus
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_tx_status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /EXPERIMENTAL_validators_ordered
     * 
     * Returns the current epoch validators ordered in the block producer order with repetition. This endpoint is solely used for bridge currently and is not intended for other external use cases.
     * @param jsonRpcRequestForEXPERIMENTALValidatorsOrdered 
     * @return JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eXPERIMENTALValidatorsOrdered(jsonRpcRequestForEXPERIMENTALValidatorsOrdered: JsonRpcRequestForEXPERIMENTALValidatorsOrdered) : JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError {
        val localVarResponse = eXPERIMENTALValidatorsOrderedWithHttpInfo(jsonRpcRequestForEXPERIMENTALValidatorsOrdered = jsonRpcRequestForEXPERIMENTALValidatorsOrdered)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /EXPERIMENTAL_validators_ordered
     * 
     * Returns the current epoch validators ordered in the block producer order with repetition. This endpoint is solely used for bridge currently and is not intended for other external use cases.
     * @param jsonRpcRequestForEXPERIMENTALValidatorsOrdered 
     * @return ApiResponse<JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eXPERIMENTALValidatorsOrderedWithHttpInfo(jsonRpcRequestForEXPERIMENTALValidatorsOrdered: JsonRpcRequestForEXPERIMENTALValidatorsOrdered) : ApiResponse<JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError?> {
        val localVariableConfig = eXPERIMENTALValidatorsOrderedRequestConfig(jsonRpcRequestForEXPERIMENTALValidatorsOrdered = jsonRpcRequestForEXPERIMENTALValidatorsOrdered)

        return request<JsonRpcRequestForEXPERIMENTALValidatorsOrdered, JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eXPERIMENTALValidatorsOrdered
     *
     * @param jsonRpcRequestForEXPERIMENTALValidatorsOrdered 
     * @return RequestConfig
     */
    fun eXPERIMENTALValidatorsOrderedRequestConfig(jsonRpcRequestForEXPERIMENTALValidatorsOrdered: JsonRpcRequestForEXPERIMENTALValidatorsOrdered) : RequestConfig<JsonRpcRequestForEXPERIMENTALValidatorsOrdered> {
        val localVariableBody = jsonRpcRequestForEXPERIMENTALValidatorsOrdered
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/EXPERIMENTAL_validators_ordered",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /gas_price
     * 
     * Returns gas price for a specific block_height or block_hash. Using [null] will return the most recent block&#39;s gas price.
     * @param jsonRpcRequestForGasPrice 
     * @return JsonRpcResponseForRpcGasPriceResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun gasPrice(jsonRpcRequestForGasPrice: JsonRpcRequestForGasPrice) : JsonRpcResponseForRpcGasPriceResponseAndRpcError {
        val localVarResponse = gasPriceWithHttpInfo(jsonRpcRequestForGasPrice = jsonRpcRequestForGasPrice)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcGasPriceResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /gas_price
     * 
     * Returns gas price for a specific block_height or block_hash. Using [null] will return the most recent block&#39;s gas price.
     * @param jsonRpcRequestForGasPrice 
     * @return ApiResponse<JsonRpcResponseForRpcGasPriceResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun gasPriceWithHttpInfo(jsonRpcRequestForGasPrice: JsonRpcRequestForGasPrice) : ApiResponse<JsonRpcResponseForRpcGasPriceResponseAndRpcError?> {
        val localVariableConfig = gasPriceRequestConfig(jsonRpcRequestForGasPrice = jsonRpcRequestForGasPrice)

        return request<JsonRpcRequestForGasPrice, JsonRpcResponseForRpcGasPriceResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gasPrice
     *
     * @param jsonRpcRequestForGasPrice 
     * @return RequestConfig
     */
    fun gasPriceRequestConfig(jsonRpcRequestForGasPrice: JsonRpcRequestForGasPrice) : RequestConfig<JsonRpcRequestForGasPrice> {
        val localVariableBody = jsonRpcRequestForGasPrice
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/gas_price",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /genesis_config
     * 
     * Get initial state and parameters for the genesis block
     * @param jsonRpcRequestForGenesisConfig 
     * @return JsonRpcResponseForGenesisConfigAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genesisConfig(jsonRpcRequestForGenesisConfig: JsonRpcRequestForGenesisConfig) : JsonRpcResponseForGenesisConfigAndRpcError {
        val localVarResponse = genesisConfigWithHttpInfo(jsonRpcRequestForGenesisConfig = jsonRpcRequestForGenesisConfig)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForGenesisConfigAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /genesis_config
     * 
     * Get initial state and parameters for the genesis block
     * @param jsonRpcRequestForGenesisConfig 
     * @return ApiResponse<JsonRpcResponseForGenesisConfigAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genesisConfigWithHttpInfo(jsonRpcRequestForGenesisConfig: JsonRpcRequestForGenesisConfig) : ApiResponse<JsonRpcResponseForGenesisConfigAndRpcError?> {
        val localVariableConfig = genesisConfigRequestConfig(jsonRpcRequestForGenesisConfig = jsonRpcRequestForGenesisConfig)

        return request<JsonRpcRequestForGenesisConfig, JsonRpcResponseForGenesisConfigAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genesisConfig
     *
     * @param jsonRpcRequestForGenesisConfig 
     * @return RequestConfig
     */
    fun genesisConfigRequestConfig(jsonRpcRequestForGenesisConfig: JsonRpcRequestForGenesisConfig) : RequestConfig<JsonRpcRequestForGenesisConfig> {
        val localVariableBody = jsonRpcRequestForGenesisConfig
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/genesis_config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /health
     * 
     * Returns the current health status of the RPC node the client connects to.
     * @param jsonRpcRequestForHealth 
     * @return JsonRpcResponseForNullableRpcHealthResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun health(jsonRpcRequestForHealth: JsonRpcRequestForHealth) : JsonRpcResponseForNullableRpcHealthResponseAndRpcError {
        val localVarResponse = healthWithHttpInfo(jsonRpcRequestForHealth = jsonRpcRequestForHealth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForNullableRpcHealthResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /health
     * 
     * Returns the current health status of the RPC node the client connects to.
     * @param jsonRpcRequestForHealth 
     * @return ApiResponse<JsonRpcResponseForNullableRpcHealthResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun healthWithHttpInfo(jsonRpcRequestForHealth: JsonRpcRequestForHealth) : ApiResponse<JsonRpcResponseForNullableRpcHealthResponseAndRpcError?> {
        val localVariableConfig = healthRequestConfig(jsonRpcRequestForHealth = jsonRpcRequestForHealth)

        return request<JsonRpcRequestForHealth, JsonRpcResponseForNullableRpcHealthResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation health
     *
     * @param jsonRpcRequestForHealth 
     * @return RequestConfig
     */
    fun healthRequestConfig(jsonRpcRequestForHealth: JsonRpcRequestForHealth) : RequestConfig<JsonRpcRequestForHealth> {
        val localVariableBody = jsonRpcRequestForHealth
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/health",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /light_client_proof
     * 
     * Returns the proofs for a transaction execution.
     * @param jsonRpcRequestForLightClientProof 
     * @return JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lightClientProof(jsonRpcRequestForLightClientProof: JsonRpcRequestForLightClientProof) : JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError {
        val localVarResponse = lightClientProofWithHttpInfo(jsonRpcRequestForLightClientProof = jsonRpcRequestForLightClientProof)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /light_client_proof
     * 
     * Returns the proofs for a transaction execution.
     * @param jsonRpcRequestForLightClientProof 
     * @return ApiResponse<JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lightClientProofWithHttpInfo(jsonRpcRequestForLightClientProof: JsonRpcRequestForLightClientProof) : ApiResponse<JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError?> {
        val localVariableConfig = lightClientProofRequestConfig(jsonRpcRequestForLightClientProof = jsonRpcRequestForLightClientProof)

        return request<JsonRpcRequestForLightClientProof, JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lightClientProof
     *
     * @param jsonRpcRequestForLightClientProof 
     * @return RequestConfig
     */
    fun lightClientProofRequestConfig(jsonRpcRequestForLightClientProof: JsonRpcRequestForLightClientProof) : RequestConfig<JsonRpcRequestForLightClientProof> {
        val localVariableBody = jsonRpcRequestForLightClientProof
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/light_client_proof",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /maintenance_windows
     * 
     * Returns the future windows for maintenance in current epoch for the specified account. In the maintenance windows, the node will not be block producer or chunk producer.
     * @param jsonRpcRequestForMaintenanceWindows 
     * @return JsonRpcResponseForArrayOfRangeOfUint64AndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun maintenanceWindows(jsonRpcRequestForMaintenanceWindows: JsonRpcRequestForMaintenanceWindows) : JsonRpcResponseForArrayOfRangeOfUint64AndRpcError {
        val localVarResponse = maintenanceWindowsWithHttpInfo(jsonRpcRequestForMaintenanceWindows = jsonRpcRequestForMaintenanceWindows)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForArrayOfRangeOfUint64AndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /maintenance_windows
     * 
     * Returns the future windows for maintenance in current epoch for the specified account. In the maintenance windows, the node will not be block producer or chunk producer.
     * @param jsonRpcRequestForMaintenanceWindows 
     * @return ApiResponse<JsonRpcResponseForArrayOfRangeOfUint64AndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun maintenanceWindowsWithHttpInfo(jsonRpcRequestForMaintenanceWindows: JsonRpcRequestForMaintenanceWindows) : ApiResponse<JsonRpcResponseForArrayOfRangeOfUint64AndRpcError?> {
        val localVariableConfig = maintenanceWindowsRequestConfig(jsonRpcRequestForMaintenanceWindows = jsonRpcRequestForMaintenanceWindows)

        return request<JsonRpcRequestForMaintenanceWindows, JsonRpcResponseForArrayOfRangeOfUint64AndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation maintenanceWindows
     *
     * @param jsonRpcRequestForMaintenanceWindows 
     * @return RequestConfig
     */
    fun maintenanceWindowsRequestConfig(jsonRpcRequestForMaintenanceWindows: JsonRpcRequestForMaintenanceWindows) : RequestConfig<JsonRpcRequestForMaintenanceWindows> {
        val localVariableBody = jsonRpcRequestForMaintenanceWindows
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/maintenance_windows",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /network_info
     * 
     * Queries the current state of node network connections. This includes information about active peers, transmitted data, known producers, etc.
     * @param jsonRpcRequestForNetworkInfo 
     * @return JsonRpcResponseForRpcNetworkInfoResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun networkInfo(jsonRpcRequestForNetworkInfo: JsonRpcRequestForNetworkInfo) : JsonRpcResponseForRpcNetworkInfoResponseAndRpcError {
        val localVarResponse = networkInfoWithHttpInfo(jsonRpcRequestForNetworkInfo = jsonRpcRequestForNetworkInfo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcNetworkInfoResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /network_info
     * 
     * Queries the current state of node network connections. This includes information about active peers, transmitted data, known producers, etc.
     * @param jsonRpcRequestForNetworkInfo 
     * @return ApiResponse<JsonRpcResponseForRpcNetworkInfoResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun networkInfoWithHttpInfo(jsonRpcRequestForNetworkInfo: JsonRpcRequestForNetworkInfo) : ApiResponse<JsonRpcResponseForRpcNetworkInfoResponseAndRpcError?> {
        val localVariableConfig = networkInfoRequestConfig(jsonRpcRequestForNetworkInfo = jsonRpcRequestForNetworkInfo)

        return request<JsonRpcRequestForNetworkInfo, JsonRpcResponseForRpcNetworkInfoResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation networkInfo
     *
     * @param jsonRpcRequestForNetworkInfo 
     * @return RequestConfig
     */
    fun networkInfoRequestConfig(jsonRpcRequestForNetworkInfo: JsonRpcRequestForNetworkInfo) : RequestConfig<JsonRpcRequestForNetworkInfo> {
        val localVariableBody = jsonRpcRequestForNetworkInfo
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/network_info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /next_light_client_block
     * 
     * Returns the next light client block.
     * @param jsonRpcRequestForNextLightClientBlock 
     * @return JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun nextLightClientBlock(jsonRpcRequestForNextLightClientBlock: JsonRpcRequestForNextLightClientBlock) : JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError {
        val localVarResponse = nextLightClientBlockWithHttpInfo(jsonRpcRequestForNextLightClientBlock = jsonRpcRequestForNextLightClientBlock)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /next_light_client_block
     * 
     * Returns the next light client block.
     * @param jsonRpcRequestForNextLightClientBlock 
     * @return ApiResponse<JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun nextLightClientBlockWithHttpInfo(jsonRpcRequestForNextLightClientBlock: JsonRpcRequestForNextLightClientBlock) : ApiResponse<JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError?> {
        val localVariableConfig = nextLightClientBlockRequestConfig(jsonRpcRequestForNextLightClientBlock = jsonRpcRequestForNextLightClientBlock)

        return request<JsonRpcRequestForNextLightClientBlock, JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation nextLightClientBlock
     *
     * @param jsonRpcRequestForNextLightClientBlock 
     * @return RequestConfig
     */
    fun nextLightClientBlockRequestConfig(jsonRpcRequestForNextLightClientBlock: JsonRpcRequestForNextLightClientBlock) : RequestConfig<JsonRpcRequestForNextLightClientBlock> {
        val localVariableBody = jsonRpcRequestForNextLightClientBlock
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/next_light_client_block",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /query
     * 
     * This module allows you to make generic requests to the network.  The &#x60;RpcQueryRequest&#x60; struct takes in a [&#x60;BlockReference&#x60;](https://docs.rs/near-primitives/0.12.0/near_primitives/types/enum.BlockReference.html) and a [&#x60;QueryRequest&#x60;](https://docs.rs/near-primitives/0.12.0/near_primitives/views/enum.QueryRequest.html).  The &#x60;BlockReference&#x60; enum allows you to specify a block by &#x60;Finality&#x60;, &#x60;BlockId&#x60; or &#x60;SyncCheckpoint&#x60;.  The &#x60;QueryRequest&#x60; enum provides multiple variants for performing the following actions:  - View an account&#39;s details  - View a contract&#39;s code  - View the state of an account  - View the &#x60;AccessKey&#x60; of an account  - View the &#x60;AccessKeyList&#x60; of an account  - Call a function in a contract deployed on the network.
     * @param jsonRpcRequestForQuery 
     * @return JsonRpcResponseForRpcQueryResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun query(jsonRpcRequestForQuery: JsonRpcRequestForQuery) : JsonRpcResponseForRpcQueryResponseAndRpcError {
        val localVarResponse = queryWithHttpInfo(jsonRpcRequestForQuery = jsonRpcRequestForQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcQueryResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /query
     * 
     * This module allows you to make generic requests to the network.  The &#x60;RpcQueryRequest&#x60; struct takes in a [&#x60;BlockReference&#x60;](https://docs.rs/near-primitives/0.12.0/near_primitives/types/enum.BlockReference.html) and a [&#x60;QueryRequest&#x60;](https://docs.rs/near-primitives/0.12.0/near_primitives/views/enum.QueryRequest.html).  The &#x60;BlockReference&#x60; enum allows you to specify a block by &#x60;Finality&#x60;, &#x60;BlockId&#x60; or &#x60;SyncCheckpoint&#x60;.  The &#x60;QueryRequest&#x60; enum provides multiple variants for performing the following actions:  - View an account&#39;s details  - View a contract&#39;s code  - View the state of an account  - View the &#x60;AccessKey&#x60; of an account  - View the &#x60;AccessKeyList&#x60; of an account  - Call a function in a contract deployed on the network.
     * @param jsonRpcRequestForQuery 
     * @return ApiResponse<JsonRpcResponseForRpcQueryResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queryWithHttpInfo(jsonRpcRequestForQuery: JsonRpcRequestForQuery) : ApiResponse<JsonRpcResponseForRpcQueryResponseAndRpcError?> {
        val localVariableConfig = queryRequestConfig(jsonRpcRequestForQuery = jsonRpcRequestForQuery)

        return request<JsonRpcRequestForQuery, JsonRpcResponseForRpcQueryResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation query
     *
     * @param jsonRpcRequestForQuery 
     * @return RequestConfig
     */
    fun queryRequestConfig(jsonRpcRequestForQuery: JsonRpcRequestForQuery) : RequestConfig<JsonRpcRequestForQuery> {
        val localVariableBody = jsonRpcRequestForQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/query",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /send_tx
     * 
     * Sends transaction. Returns the guaranteed execution status and the results the blockchain can provide at the moment.
     * @param jsonRpcRequestForSendTx 
     * @return JsonRpcResponseForRpcTransactionResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendTx(jsonRpcRequestForSendTx: JsonRpcRequestForSendTx) : JsonRpcResponseForRpcTransactionResponseAndRpcError {
        val localVarResponse = sendTxWithHttpInfo(jsonRpcRequestForSendTx = jsonRpcRequestForSendTx)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcTransactionResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /send_tx
     * 
     * Sends transaction. Returns the guaranteed execution status and the results the blockchain can provide at the moment.
     * @param jsonRpcRequestForSendTx 
     * @return ApiResponse<JsonRpcResponseForRpcTransactionResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sendTxWithHttpInfo(jsonRpcRequestForSendTx: JsonRpcRequestForSendTx) : ApiResponse<JsonRpcResponseForRpcTransactionResponseAndRpcError?> {
        val localVariableConfig = sendTxRequestConfig(jsonRpcRequestForSendTx = jsonRpcRequestForSendTx)

        return request<JsonRpcRequestForSendTx, JsonRpcResponseForRpcTransactionResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendTx
     *
     * @param jsonRpcRequestForSendTx 
     * @return RequestConfig
     */
    fun sendTxRequestConfig(jsonRpcRequestForSendTx: JsonRpcRequestForSendTx) : RequestConfig<JsonRpcRequestForSendTx> {
        val localVariableBody = jsonRpcRequestForSendTx
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/send_tx",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /status
     * 
     * Requests the status of the connected RPC node. This includes information about sync status, nearcore node version, protocol version, the current set of validators, etc.
     * @param jsonRpcRequestForStatus 
     * @return JsonRpcResponseForRpcStatusResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun status(jsonRpcRequestForStatus: JsonRpcRequestForStatus) : JsonRpcResponseForRpcStatusResponseAndRpcError {
        val localVarResponse = statusWithHttpInfo(jsonRpcRequestForStatus = jsonRpcRequestForStatus)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcStatusResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /status
     * 
     * Requests the status of the connected RPC node. This includes information about sync status, nearcore node version, protocol version, the current set of validators, etc.
     * @param jsonRpcRequestForStatus 
     * @return ApiResponse<JsonRpcResponseForRpcStatusResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun statusWithHttpInfo(jsonRpcRequestForStatus: JsonRpcRequestForStatus) : ApiResponse<JsonRpcResponseForRpcStatusResponseAndRpcError?> {
        val localVariableConfig = statusRequestConfig(jsonRpcRequestForStatus = jsonRpcRequestForStatus)

        return request<JsonRpcRequestForStatus, JsonRpcResponseForRpcStatusResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation status
     *
     * @param jsonRpcRequestForStatus 
     * @return RequestConfig
     */
    fun statusRequestConfig(jsonRpcRequestForStatus: JsonRpcRequestForStatus) : RequestConfig<JsonRpcRequestForStatus> {
        val localVariableBody = jsonRpcRequestForStatus
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /tx
     * 
     * Queries status of a transaction by hash and returns the final transaction result.
     * @param jsonRpcRequestForTx 
     * @return JsonRpcResponseForRpcTransactionResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tx(jsonRpcRequestForTx: JsonRpcRequestForTx) : JsonRpcResponseForRpcTransactionResponseAndRpcError {
        val localVarResponse = txWithHttpInfo(jsonRpcRequestForTx = jsonRpcRequestForTx)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcTransactionResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tx
     * 
     * Queries status of a transaction by hash and returns the final transaction result.
     * @param jsonRpcRequestForTx 
     * @return ApiResponse<JsonRpcResponseForRpcTransactionResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun txWithHttpInfo(jsonRpcRequestForTx: JsonRpcRequestForTx) : ApiResponse<JsonRpcResponseForRpcTransactionResponseAndRpcError?> {
        val localVariableConfig = txRequestConfig(jsonRpcRequestForTx = jsonRpcRequestForTx)

        return request<JsonRpcRequestForTx, JsonRpcResponseForRpcTransactionResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tx
     *
     * @param jsonRpcRequestForTx 
     * @return RequestConfig
     */
    fun txRequestConfig(jsonRpcRequestForTx: JsonRpcRequestForTx) : RequestConfig<JsonRpcRequestForTx> {
        val localVariableBody = jsonRpcRequestForTx
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tx",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /validators
     * 
     * Queries active validators on the network. Returns details and the state of validation on the blockchain.
     * @param jsonRpcRequestForValidators 
     * @return JsonRpcResponseForRpcValidatorResponseAndRpcError
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validators(jsonRpcRequestForValidators: JsonRpcRequestForValidators) : JsonRpcResponseForRpcValidatorResponseAndRpcError {
        val localVarResponse = validatorsWithHttpInfo(jsonRpcRequestForValidators = jsonRpcRequestForValidators)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JsonRpcResponseForRpcValidatorResponseAndRpcError
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /validators
     * 
     * Queries active validators on the network. Returns details and the state of validation on the blockchain.
     * @param jsonRpcRequestForValidators 
     * @return ApiResponse<JsonRpcResponseForRpcValidatorResponseAndRpcError?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun validatorsWithHttpInfo(jsonRpcRequestForValidators: JsonRpcRequestForValidators) : ApiResponse<JsonRpcResponseForRpcValidatorResponseAndRpcError?> {
        val localVariableConfig = validatorsRequestConfig(jsonRpcRequestForValidators = jsonRpcRequestForValidators)

        return request<JsonRpcRequestForValidators, JsonRpcResponseForRpcValidatorResponseAndRpcError>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation validators
     *
     * @param jsonRpcRequestForValidators 
     * @return RequestConfig
     */
    fun validatorsRequestConfig(jsonRpcRequestForValidators: JsonRpcRequestForValidators) : RequestConfig<JsonRpcRequestForValidators> {
        val localVariableBody = jsonRpcRequestForValidators
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/validators",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
