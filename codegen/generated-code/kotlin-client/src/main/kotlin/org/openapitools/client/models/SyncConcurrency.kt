/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.models


import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

/**
 * 
 *
 * @param apply Maximum number of \"apply parts\" tasks that can be performed in parallel. This is a very disk-heavy task and therefore we set this to a low limit, or else the rocksdb contention makes the whole server freeze up.
 * @param applyDuringCatchup Maximum number of \"apply parts\" tasks that can be performed in parallel during catchup. We set this to a very low value to avoid overloading the node while it is still performing normal tasks.
 * @param peerDownloads Maximum number of outstanding requests for decentralized state sync.
 * @param perShard The maximum parallelism to use per shard. This is mostly for fairness, because the actual rate limiting is done by the TaskTrackers, but this is useful for balancing the shards a little.
 */


data class SyncConcurrency (

    /* Maximum number of \"apply parts\" tasks that can be performed in parallel. This is a very disk-heavy task and therefore we set this to a low limit, or else the rocksdb contention makes the whole server freeze up. */
    @Json(name = "apply")
    val apply: kotlin.Int,

    /* Maximum number of \"apply parts\" tasks that can be performed in parallel during catchup. We set this to a very low value to avoid overloading the node while it is still performing normal tasks. */
    @Json(name = "apply_during_catchup")
    val applyDuringCatchup: kotlin.Int,

    /* Maximum number of outstanding requests for decentralized state sync. */
    @Json(name = "peer_downloads")
    val peerDownloads: kotlin.Int,

    /* The maximum parallelism to use per shard. This is mostly for fairness, because the actual rate limiting is done by the TaskTrackers, but this is useful for balancing the shards a little. */
    @Json(name = "per_shard")
    val perShard: kotlin.Int

) {


}

