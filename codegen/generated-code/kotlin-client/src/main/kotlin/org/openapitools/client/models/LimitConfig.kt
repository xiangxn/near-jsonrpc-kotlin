/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.models


import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

/**
 * Describes limits for VM and Runtime. TODO #4139: consider switching to strongly-typed wrappers instead of raw quantities
 *
 * @param initialMemoryPages The initial number of memory pages. NOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages.
 * @param maxActionsPerReceipt Max number of actions per receipt.
 * @param maxArgumentsLength Max length of arguments in a function call action.
 * @param maxContractSize Max contract size
 * @param maxGasBurnt Max amount of gas that can be used, excluding gas attached to promises.
 * @param maxLengthMethodName Max length of any method name (without terminating character).
 * @param maxLengthReturnedData Max length of returned data
 * @param maxLengthStorageKey Max storage key size
 * @param maxLengthStorageValue Max storage value size
 * @param maxMemoryPages What is the maximal memory pages amount is allowed to have for a contract.
 * @param maxNumberBytesMethodNames Max total length of all method names (including terminating character) for a function call permission access key.
 * @param maxNumberInputDataDependencies Max number of input data dependencies
 * @param maxNumberLogs Maximum number of log entries.
 * @param maxNumberRegisters Maximum number of registers that can be used simultaneously.  Note that due to an implementation quirk [read: a bug] in VMLogic, if we have this number of registers, no subsequent writes to the registers will succeed even if they replace an existing register.
 * @param maxPromisesPerFunctionCallAction Max number of promises that a function call can create
 * @param maxReceiptSize Max receipt size
 * @param maxRegisterSize Maximum number of bytes that can be stored in a single register.
 * @param maxStackHeight How tall the stack is allowed to grow?  See <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost is calculated.
 * @param maxTotalLogLength Maximum total length in bytes of all log messages.
 * @param maxTotalPrepaidGas Max total prepaid gas for all function call actions per receipt.
 * @param maxTransactionSize Max transaction size
 * @param maxYieldPayloadSize Maximum number of bytes for payload passed over a yield resume.
 * @param perReceiptStorageProofSizeLimit Hard limit on the size of storage proof generated while executing a single receipt.
 * @param registersMemoryLimit Limit of memory used by registers.
 * @param yieldTimeoutLengthInBlocks Number of blocks after which a yielded promise times out.
 * @param accountIdValidityRulesVersion Whether to enforce account_id well-formed-ness where it wasn't enforced historically.
 * @param maxElementsPerContractTable If present, stores max number of elements in a single contract's table
 * @param maxFunctionsNumberPerContract If present, stores max number of functions in one contract
 * @param maxLocalsPerContract If present, stores max number of locals declared globally in one contract
 * @param maxTablesPerContract If present, stores max number of tables declared globally in one contract
 */


data class LimitConfig (

    /* The initial number of memory pages. NOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages. */
    @Json(name = "initial_memory_pages")
    val initialMemoryPages: kotlin.Int,

    /* Max number of actions per receipt. */
    @Json(name = "max_actions_per_receipt")
    val maxActionsPerReceipt: kotlin.Int,

    /* Max length of arguments in a function call action. */
    @Json(name = "max_arguments_length")
    val maxArgumentsLength: kotlin.Int,

    /* Max contract size */
    @Json(name = "max_contract_size")
    val maxContractSize: kotlin.Int,

    /* Max amount of gas that can be used, excluding gas attached to promises. */
    @Json(name = "max_gas_burnt")
    val maxGasBurnt: kotlin.Int,

    /* Max length of any method name (without terminating character). */
    @Json(name = "max_length_method_name")
    val maxLengthMethodName: kotlin.Int,

    /* Max length of returned data */
    @Json(name = "max_length_returned_data")
    val maxLengthReturnedData: kotlin.Int,

    /* Max storage key size */
    @Json(name = "max_length_storage_key")
    val maxLengthStorageKey: kotlin.Int,

    /* Max storage value size */
    @Json(name = "max_length_storage_value")
    val maxLengthStorageValue: kotlin.Int,

    /* What is the maximal memory pages amount is allowed to have for a contract. */
    @Json(name = "max_memory_pages")
    val maxMemoryPages: kotlin.Int,

    /* Max total length of all method names (including terminating character) for a function call permission access key. */
    @Json(name = "max_number_bytes_method_names")
    val maxNumberBytesMethodNames: kotlin.Int,

    /* Max number of input data dependencies */
    @Json(name = "max_number_input_data_dependencies")
    val maxNumberInputDataDependencies: kotlin.Int,

    /* Maximum number of log entries. */
    @Json(name = "max_number_logs")
    val maxNumberLogs: kotlin.Int,

    /* Maximum number of registers that can be used simultaneously.  Note that due to an implementation quirk [read: a bug] in VMLogic, if we have this number of registers, no subsequent writes to the registers will succeed even if they replace an existing register. */
    @Json(name = "max_number_registers")
    val maxNumberRegisters: kotlin.Int,

    /* Max number of promises that a function call can create */
    @Json(name = "max_promises_per_function_call_action")
    val maxPromisesPerFunctionCallAction: kotlin.Int,

    /* Max receipt size */
    @Json(name = "max_receipt_size")
    val maxReceiptSize: kotlin.Int,

    /* Maximum number of bytes that can be stored in a single register. */
    @Json(name = "max_register_size")
    val maxRegisterSize: kotlin.Int,

    /* How tall the stack is allowed to grow?  See <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost is calculated. */
    @Json(name = "max_stack_height")
    val maxStackHeight: kotlin.Int,

    /* Maximum total length in bytes of all log messages. */
    @Json(name = "max_total_log_length")
    val maxTotalLogLength: kotlin.Int,

    /* Max total prepaid gas for all function call actions per receipt. */
    @Json(name = "max_total_prepaid_gas")
    val maxTotalPrepaidGas: kotlin.Int,

    /* Max transaction size */
    @Json(name = "max_transaction_size")
    val maxTransactionSize: kotlin.Int,

    /* Maximum number of bytes for payload passed over a yield resume. */
    @Json(name = "max_yield_payload_size")
    val maxYieldPayloadSize: kotlin.Int,

    /* Hard limit on the size of storage proof generated while executing a single receipt. */
    @Json(name = "per_receipt_storage_proof_size_limit")
    val perReceiptStorageProofSizeLimit: kotlin.Int,

    /* Limit of memory used by registers. */
    @Json(name = "registers_memory_limit")
    val registersMemoryLimit: kotlin.Int,

    /* Number of blocks after which a yielded promise times out. */
    @Json(name = "yield_timeout_length_in_blocks")
    val yieldTimeoutLengthInBlocks: kotlin.Int,

    /* Whether to enforce account_id well-formed-ness where it wasn't enforced historically. */
    @Json(name = "account_id_validity_rules_version")
    val accountIdValidityRulesVersion: kotlin.Int? = null,

    /* If present, stores max number of elements in a single contract's table */
    @Json(name = "max_elements_per_contract_table")
    val maxElementsPerContractTable: kotlin.Int? = null,

    /* If present, stores max number of functions in one contract */
    @Json(name = "max_functions_number_per_contract")
    val maxFunctionsNumberPerContract: kotlin.Int? = null,

    /* If present, stores max number of locals declared globally in one contract */
    @Json(name = "max_locals_per_contract")
    val maxLocalsPerContract: kotlin.Int? = null,

    /* If present, stores max number of tables declared globally in one contract */
    @Json(name = "max_tables_per_contract")
    val maxTablesPerContract: kotlin.Int? = null

) {


}

